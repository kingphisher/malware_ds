#!/usr/bin/python3
# Tool to dissect PE files

import pefile
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('mode', help='section | library')
parser.add_argument('file', help='PE file')
args = parser.parse_args()

# Calling the PE constructor, to load and parse the specified PE file.
try:
    pe = pefile.PE(args.file)
    if args.mode == 'section': # Print information about PE file's sections
        print('-----------------------------------------------------------------')
        print('| Section Name | Virtual Address | Virtual Size | Raw Data Size |')
        print('-----------------------------------------------------------------')
        for section in pe.sections:
            # print(len(section.Name.decode('utf-8').replace('\x00', '')), hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData))
            sn = section.Name.decode('utf-8').rstrip('x\00')
            va = hex(section.VirtualAddress).rstrip('x\00')
            vs = hex(section.Misc_VirtualSize).rstrip('x\00')
            data_size = hex(section.SizeOfRawData).rstrip('x\00')
            print(
                '|{}{}{}'.format(' ' * 4, sn, ' ' * (9 - len(sn))),
                '|{}{}{}'.format(' ' * 5, va, ' ' * (11 - len(va))),
                '|{}{}{}'.format(' ' * 3, vs, ' ' * (10 - len(vs))),
                '|{}{}{}|'.format(' ' * 3, data_size, ' ' * (12 - len(data_size)))
                )
        print('-----------------------------------------------------------------')
    elif args.mode == 'library': # Extract imports and listing the contents of the IAT, such as function calls.
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            print(entry.dll.decode('utf-8'))
            for function in entry.imports:
                print('\t', function.name.decode('utf-8'))
    else:
        print('Mode not supported')
except:
    print('File not found')